<h1 align="center" style="margin: 30px 0 30px; font-weight: bold;">shardingjdbc-example</h1>
<p align="center">
	<a href="#"><img src="https://img.shields.io/badge/Springboot-2.3.12-blue"></a>
	<a href="#"><img src="https://img.shields.io/badge/license%20-MIT-green"></a>
</p>

# 介绍

ShardingJDBC 网关学习用例

## 项目

| # | 目录                              | 说明                    |
| --- | ------------------------- | ------------------------- |
| 1 | [shardingjdbc-demo1](./shardingjdbc-demo1)  | 简单实现分表操作 |
| 2 | [shardingjdbc-demo2](./shardingjdbc-demo2)  | 雪花算法生成ID方式 |
| 3 | [shardingjdbc-demo3](./shardingjdbc-demo3)  | 广播表 |
| 4 | [shardingjdbc-demo4](./shardingjdbc-demo4)  | 绑定表 |
| 5 | [shardingjdbc-demo5](./shardingjdbc-demo5)  | 分片策略（精准分片算法、范围分片算法）  |
| 6 | [shardingjdbc-demo6](./shardingjdbc-demo6)  | 分片策略（复合分片算法(用的不多，了解就好)）  |
| 7 | [shardingjdbc-demo7](./shardingjdbc-demo7)  | 分片策略（Hint分片算法）  |


<br><br>
## 常见数据库分库分表中间件

- Mycat
- Sharding-JDBC


<br>


## 数据库架构演变历史

### 单机

- 请求量大查询慢
- 单机故障导致业务不可用

### 主从

- 数据库主从同步，从库可以水平扩展，满足更大读需求
- 但单服务器TPS，内存，IO都是有限的

### 双主

- 用户量级上来后，写请求越来越多
- 一个Master是不能解决问题的，添加多了个主节点进行写入，
- 多个主节点数据要保存一致性，写操作需要2个master之间同步更加复杂


### 分库和分表


<br>


## 数据库性能优化思路

要根据实际情况分析

### 软优化

- 数据库参数调优
- 分析慢查询SQL语句，分析执行计划，进行sql改写和程序改写
- 优化数据库索引结构
- 优化数据表结构优化
- 引入NOSQL和程序架构调整


## 硬优化

- 提升系统硬件（更快的IO、更多的内存）：带宽、CPU、硬盘

### 分库分表

- 根据业务情况而定，选择合适的分库分表策略（没有通用的策略）
- 数据库分表能够解决单表数据量很大的时,数据查询的效率问题，
- 无法给数据库的并发操作带来效率上的提高，分表的实质还是在一个数据库上进行的操作，受数据库IO性能的限制
- 单分表满足不了需求，再分库分表一起

### 结论

- 在数据量及访问压力不是特别大的情况，首先考虑缓存、读写分离、索引技术等方案
- 如果数据量极大，且业务持续增长快，再考虑分库分表方案


<br>


## 分库分表解决的现状问题

### 解决数据库本身瓶颈

- 连接数： 连接数过多时，就会出现‘too many connections’的错误，访问量太大或者数据库设置的最大连接数太小的原因
- Mysql默认的最大连接数为100.可以修改，而mysql服务允许的最大连接数为16384
- 数据库分表可以解决单表海量数据的查询性能问题
- 数据库分库可以解决单台数据库的并发访问压力问题

### 解决系统本身IO、CPU瓶颈

- 磁盘读写IO瓶颈，热点数据太多，尽管使用了数据库本身缓存，但是依旧有大量IO,导致sql执行速度慢
- 网络IO瓶颈，请求的数据太多，数据传输大，网络带宽不够，链路响应时间变长
- CPU瓶颈，尤其在基础数据量大单机复杂SQL计算，SQL语句执行占用CPU使用率高，也有扫描行数大、锁冲突、锁等待等原因

  - 可以通过 show processlist; 、show full processlist，发现 CPU 使用率比较高的SQL
  - 常见的对于查询时间长，State 列值是 Sending data，Copying to tmp table，Copying to tmp table on disk，Sorting result，Using filesort 等都是可能有性能问题SQL，清楚相关影响问题的情况可以kill掉
  - 也存在执行时间短，但是CPU占用率高的SQL，通过上面命令查询不到，这个时候最好通过执行计划分析explain进行分析


<br>


## 分库分表解决带来的新问题

**问题一：跨节点数据库Join关联查询**

- 数据库切分前，多表关联查询，可以通过sql join进行实现
- 分库分表后，数据可能分布在不同的节点上，sql join带来的问题就比较麻烦


**问题二：分库操作带来的分布式事务问题**

- 操作内容同时分布在不同库中，不可避免会带来跨库事务问题，即分布式事务


**问题三：执行的SQL排序、翻页、函数计算问题**

- 分库后，数据分布再不同的节点上， 跨节点多库进行查询时，会出现limit分页、order by排序等问题
- 而且当排序字段非分片字段时，更加复杂了，要在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序（也会带来更多的CPU/IO资源损耗）


**问题四：数据库全局主键重复问题**

- 常规表的id是使用自增id进行实现，分库分表后，由于表中数据同时存在不同数据库中，如果用自增id，则会出现冲突问题


**问题五：容量规划,分库分表后二次扩容问题**

- 业务发展快，初次分库分表后，满足不了数据存储，导致需要多次扩容


**问题六：分库分表技术选型问题**

- 市场分库分表中间件相对较多，框架各有各的优势与短板，应该如何选择


<br>



## 拆分原则

### 垂直拆分

垂直拆分，是对表结构拆分。

#### 介绍

- 也就是“大表拆小表”，基于列字段进行的
- 拆分原则一般是表中的字段较多，将不常用的或者数据较大，长度较长的拆分到“扩展表 如text类型字段
- 访问频次低、字段大的商品描述信息单独存放在一张表中，访问频次较高的商品基本信息单独放在一张表中

#### 垂直拆分原则

- 把不常用的字段单独放在一张表;
- 把text，blob等大字段拆分出来放在附表中;
- 业务经常组合查询的列放在一张表中

<br>

垂直分表: 将一个表字段拆分多个表，每个表存储部分字段

- 好处: 避免IO时锁表的次数，分离热点字段和非热点字段，避免大字段IO导致性能下降

- 原则：业务经常组合查询的字段一个表；不常用字段一个表；text、blob类型字段作为附属表

垂直分库：根据业务将表分类，放到不同的数据库服务器上

- 好处：避免表之间竞争同个物理机的资源，比如CPU/内存/硬盘/网络IO
- 原则：根据业务相关性进行划分，领域模型，微服务划分一般就是垂直分库

<br>

### 水平拆分

水平拆分，是对数据拆分。

#### 介绍

- 把一个表的数据分到一个数据库的多张表中，每个表只有这个表的部分数据
- 核心是把一个大表，分割N个小表，每个表的结构是一样的，数据不一样，全部表的数据合起来就是全部数据
- 针对数据量巨大的单张表（比如订单表），按照某种规则（RANGE,HASH取模等），切分到多张表里面去
- 但是这些表还是在同一个库中，所以单数据库操作还是有IO瓶颈，主要是解决单表数据量过大的问题
- 减少锁表时间，没分表前，如果是DDL(create/alter/add等)语句，当需要添加一列的时候mysql会锁表，期间所有的读写操作只能等待


水平分库：把同个表的数据按照一定规则分到不同的数据库中，数据库在不同的服务器上

- 好处: 多个数据库，降低了系统的IO和CPU压力
- 原则
  - 选择合适的分片键和分片策略，和业务场景配合
  - 避免数据热点和访问不均衡、避免二次扩容难度大

<br>

水平分表：同个数据库内，把一个表的数据按照一定规则拆分到多个表中，对数据进行拆分，不影响表结构

- 单个表的数据量少了，业务SQL执行效率高，降低了系统的IO和CPU压力
- 原则
  - 选择合适的分片键和分片策略，和业务场景配合
  - 避免数据热点和访问不均衡、避免二次扩容难度大



<br>



## 分库分表策略

### 根据ID范围进行分表

**优点**

- id是自增长，可以无限增长
- 扩容不用迁移数据，容易理解和维护

**缺点**

- 大部分读和写都访会问新的数据，有IO瓶颈，整体资源利用率低
- 数据倾斜严重，热点数据过于集中，部分节点有瓶颈

### hash取模（Hash分库分表是最普遍的方案）

**优点**

- 保证数据较均匀的分散落在不同的库、表中，可以有效的避免热点数据集中问题，

**缺点**

- 扩容不是很方便，需要数据迁移






<br>






## 分片策略

### 1. 行表达式分片策略(重要)

**InlineShardingStrategy**

- 只支持【单分片键】使用Groovy的表达式，提供对SQL语句中的 =和IN 的分片操作支持
- 可以通过简单的配置使用，无需自定义分片算法，从而避免繁琐的Java代码开发

**优缺点**

- 优点：可以根据分片策略代码里面自己拼装 真实的数据库、真实的表，灵活控制分片规则
- 缺点：增加了编码，不规范的sql容易造成全库表扫描，部分sql语法支持不友好


### 2. 标准分片策略

- 只支持【单分片键】，提供PreciseShardingAlgorithm和RangeShardingAlgorithm两个分片算法
- PreciseShardingAlgorithm 精准分片 是必选的，用于处理=和IN的分片
- RangeShardingAlgorithm 范围分配 是可选的，用于处理BETWEEN AND分片
- 如果不配置RangeShardingAlgorithm，如果SQL中用了BETWEEN AND语法，则将按照全库路由处理，性能下降


#### 精准分片策略 - StandardShardingStrategy

- 只支持【单分片键】，提供PreciseShardingAlgorithm和RangeShardingAlgorithm两个分片算法
- PreciseShardingAlgorithm 精准分片 是必选的，用于处理=和IN的分片
- RangeShardingAlgorithm 范围分片 是可选的，用于处理BETWEEN AND分片
- 如果不配置RangeShardingAlgorithm，如果SQL中用了BETWEEN AND语法，则将按照全库路由处理，性能下降


#### 范围分片策略 - RangeShardingAlgorithm

- 用于处理BETWEEN AND语法，没配置的话会报错 Cannot find range sharding strategy in sharding rule.
- 主要是会根据 SQL中给出的分片健值范围值处理分库、分表逻辑


### 3. 复合分片策略(用的不多，了解就好)

- 支持【多分片键】，多分片键之间的关系复杂，由开发者自己实现，提供最大的灵活度
- 提供对SQL语句中的=, IN和BETWEEN AND的分片操作支持

#### 复合分片算法 - ComplexShardingStrategy

- 提供对SQL语句中的=, IN和BETWEEN AND的分片操作，支持【多分片键】
- 由于多分片键之间的关系复杂，Sharding-JDBC并未做过多的封装
- 而是直接将分片键值组合以及分片操作符交于算法接口，全部由应用开发者实现，提供最大的灵活度


### 4. Hint分片策略

- 这种分片策略无需配置分片健，分片健值也不再从 SQL中解析，外部手动指定分片健或分片库，让 SQL在指定的分库、分表中执行
- 用于处理使用Hint行分片的场景，通过Hint而非SQL解析的方式分片的策略
- Hint策略会绕过SQL解析的，对于这些比较复杂的需要分片的查询，Hint分片策略性能可能会更好
- 可以指定sql去某个库某个表进行执行


#### Hint分片策略 - HintShardingStrategy


### 5. 不分片策略 NoneShardingStrategy

- 不分片的策略。

